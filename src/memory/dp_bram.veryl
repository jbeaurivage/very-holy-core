/// Dual-port Block RAM.
/// Port A can be read and written. Supports
/// individual byte writes.
///
///Port B only supports reads.
///
/// Memory is word-addressed. Use write_byte_enable
/// to enable write to individual bytes.
pub module DualPortBlockRam #(
    /// Initialize memory with hex file if not empty
    param INIT_FILE: string = "",
    /// Number of columns per entry. Default 4 = 4 bytes/word
    param NUM_COL: u8 = 4,
    /// Number of bits per column. Default 8 bits = 1 byte
    param COL_WIDTH: u8 = 8,
    /// Number of entries in RAM. Default 1024 = 1024 32-bit words
    param RAM_DEPTH: u32 = 1024,
) (
    clk  : input clock,
    rst_n: input logic,

    enable_a           : input  bool             ,
    address_a          : input  logic<ADDR_WIDTH>,
    write_data_a       : input  logic<DATA_WIDTH>,
    byte_write_enable_a: input  logic<NUM_COL>   ,
    read_data_a        : output logic<DATA_WIDTH>,

    enable_b   : input  bool             ,
    address_b  : input  logic<ADDR_WIDTH>,
    read_data_b: output logic<DATA_WIDTH>,
) {
    const ADDR_WIDTH: u32                           = $clog2(RAM_DEPTH);
    const DATA_WIDTH: u8                            = NUM_COL * COL_WIDTH;
    var mem       : logic<DATA_WIDTH> [RAM_DEPTH];

    initial {
        if INIT_FILE != "" {
            $readmemh(INIT_FILE, mem);
        }
    }

    always_ff {
        for i: u32 in 0..NUM_COL {
            if enable_a {
                if byte_write_enable_a[i] {
                    mem[address_a][(i * COL_WIDTH)+:COL_WIDTH] = write_data_a[(i * COL_WIDTH)+:COL_WIDTH];
                }
            }
        }
    }

    always_ff {
        if !rst_n {
            read_data_a = 0;
        } else if enable_a {
            read_data_a = mem[address_a];
        }
    }

    always_ff {
        if !rst_n {
            read_data_b = 0;
        } else if enable_b {
            read_data_b = mem[address_b];
        }
    }
}
