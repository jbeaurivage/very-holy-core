module Soc (
    clk  : input clock,
    rst_n: input reset,

    led   : output logic<7>,
    usb_rx: input  logic   ,
    usb_tx: output logic   ,
) {

    // Activity LED
    // All this is to keep synthesis from optimizing design out
    var tick: bool;
    always_ff {
        if_reset {
            tick     = false;
            led[6:1] = 6'b000000;
            usb_tx   = 0;
        } else {
            tick   = !tick;
            led[6] = tick;
            led[0] = if instruction == 32'h00000013 ? 1 : 0;

        }
    }

    inst cpu: Cpu (
        clk    ,
        rst_n  ,

        imem_addr    ,
        instruction  ,

        dmem_addr               ,
        dmem_read_data          ,
        dmem_write_data         ,
        dmem_byte_write_enable  ,

    );

    // Instruction memory
    // Acts as a ROM.

    // The fetched instruction we will decode and execute.
    var instruction: logic<32>;
    var imem_addr  : logic<32>;

    inst instruction_memory: MemoryController #(
        RAM_DEPTH: 1024           ,
        INIT_FILE: "test_imem.hex",
    ) (
        clk               ,
        rst_n             ,
        address: imem_addr,
        // Disallow any write in instruction mem
        byte_write_enable: 4'b0000     ,
        write_data       : 32'hxxxxxxxx,

        read_data: instruction,
    );

    var dmem_addr             : logic<32>;
    var dmem_write_data       : logic<32>;
    var dmem_byte_write_enable: logic<4> ;
    var dmem_read_data        : logic<32>;

    // Data memory
    inst data_memory: MemoryController #(
        RAM_DEPTH: 1024,
    ) (
        clk                                      ,
        rst_n                                    ,
        address          : dmem_addr             ,
        write_data       : dmem_write_data       ,
        byte_write_enable: dmem_byte_write_enable,
        read_data        : dmem_read_data        ,
    );
}
