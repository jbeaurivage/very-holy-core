import types::*;

module Cpu (
    clk  : input clock,
    rst_n: input reset,
) {
    const RESET_CYCLES: u8 = 1;

    // Delay PC advancement by one clock cycle after reset
    // to allow fetching first instruction
    var pc_reset: logic;

    inst reset_controller: ResetController #(
        NUM_CYCLES: RESET_CYCLES,
    ) (
        clk              ,
        rst_in : rst_n   ,
        rst_out: pc_reset,
    );

    // Current program counter
    var pc: logic<32>;

    // Address at which the instruction will be read.
    // Allows for reading address 0x00 into instruction
    // 1 cycle before PC starts advancing.
    var pc_read: logic<32>;

    // Next instruction to fetch
    var pc_next: logic<32>;

    // Self explanatory
    var pc_plus_four: logic<32>;

    // Used for arithmetic manipulations on PC
    var pc_plus_second_add: logic<32>;

    inst pc_selector: PcSelect (
        clk                        ,
        rst              : pc_reset,
        pc_source                  ,
        second_add_source          ,
        read_reg1        : src1    ,
        immediate                  ,

        pc                  ,
        pc_read             ,
        pc_next             ,
        pc_plus_four        ,
        pc_plus_second_add  ,
    );

    // The fetched instruction
    var instruction: logic<32>;

    // Instruction memory
    // Acts as a ROM.
    inst instruction_memory: MemoryController #(
        RAM_DEPTH: 1024,
    ) (
        clk             ,
        rst_n           ,
        address: pc_read,
        // Disallow any write
        byte_write_enable: 4'b0000,
        write_data       : 32'bx  ,

        read_data: instruction,
    );

    // Control

    // Intercepts instructions data, generate control signals accordingly
    // in control unit
    let op          : logic<7> = instruction[6:0];
    let f3          : logic<3> = instruction[14:12];
    let f7          : logic<7> = instruction[31:25];
    var alu_zero    : logic   ;
    var alu_last_bit: logic   ;

    // Out of control unit
    var alu_control      : logic<4>;
    var imm_source       : logic<3>;
    var mem_write        : bool    ;
    var reg_write        : bool    ;
    var second_add_source: logic<2>;

    // Out muxes wires
    var alu_source       : logic   ;
    var write_back_source: logic<2>;
    var pc_source        : logic   ;

    inst control_unit: Control (
        op              ,
        func3       : f3,
        func7       : f7,
        alu_zero        ,
        alu_last_bit    ,

        alu_control              ,
        imm_source               ,
        mem_write                ,
        mem_read   : read_request,
        reg_write                ,

        alu_source         ,
        write_back_source  ,
        pc_source          ,
        second_add_source  ,
    );

    // Regfile
    let source_reg1: logic<5>  = instruction[19:15];
    let source_reg2: logic<5>  = instruction[24:20];
    var read_reg1  : logic<32>;
    var read_reg2  : logic<32>;

    // The data that's currently being written back to the regfile
    var writeback: Writeback;
    // Prepare the next writeback in the pipeline
    var next_writeback: Writeback;

    // The actual data which will be written back to the register
    var writeback_data: logic<32>;
    // Destination register address for writebacks
    let next_wb_dest_reg: logic<5> = instruction[11:7];
    // Is writeback enabled this cycle?
    var writeback_enable: bool;

    inst wb_controller: WritebackControl (
        clk                                  ,
        dest_reg          : next_wb_dest_reg ,
        reg_write                            ,
        byte_enable_mask  : mem_byte_enable  ,
        f3                                   ,
        data_source       : write_back_source,
        alu_result                           ,
        pc_plus_four                         ,
        pc_plus_second_add                   ,

        mem_read_data   ,
        mem_read_valid  ,

        writeback                       ,
        next_writeback                  ,
        wb_data       : writeback_data  ,
        wb_enable     : writeback_enable,
    );

    inst regfile: Regfile (
        clk    ,
        rst_n  ,

        address1: source_reg1,
        address2: source_reg2,

        read_data1: read_reg1,
        read_data2: read_reg2,

        write_enable: writeback_enable  ,
        write_data  : writeback_data    ,
        address3    : writeback.dest_reg,
    );

    // Sign extend
    let raw_imm  : logic<25> = instruction[31:7];
    var immediate: logic<32>;

    inst sign_extender: Signext (
        raw_src   : raw_imm,
        imm_source         ,
        immediate          ,
    );

    // ALU
    var alu_result: logic<32>;

    var src1: logic<32>;
    var src2: logic<32>;

    always_comb {
        if writeback_enable && source_reg1 == writeback.dest_reg {
            if writeback.is_mem_read {
                src1 = mem_read_data;
            } else {
                src1 = writeback.data;
            }
        } else {
            src1 = read_reg1;
        }

        if writeback_enable && source_reg2 == writeback.dest_reg {
            if writeback.is_mem_read {
                src2 = mem_read_data;
            } else {
                src2 = writeback.data;
            }
        } else {
            src2 = read_reg2;
        }

    }

    let alu_src2: logic<32> = case alu_source {
        1'b1   : immediate,
        default: src2,
    };

    inst alu: Alu (
        alu_control              ,
        src1       : src1        ,
        src2       : alu_src2    ,
        alu_result               ,
        zero       : alu_zero    ,
        last_bit   : alu_last_bit,
    );

    // Load/store decoder
    var mem_byte_enable: logic<4> ;
    var mem_write_data : logic<32>;

    inst load_store_decoder: LoadStoreDecoder (
        address    : alu_result     ,
        f3                          ,
        data_in    : src2           ,
        byte_enable: mem_byte_enable,
        data_out   : mem_write_data ,
    );

    var mem_read_data : logic<32>;
    var mem_read_valid: bool     ;


    // Data memory
    var mem_raw_read     : logic<32>;
    var read_request     : bool     ;
    let byte_write_enable: logic<4>  = if mem_write ? mem_byte_enable : 4'b0000;

    inst data_memory: MemoryController #(
        RAM_DEPTH: 1024,
    ) (
        clk                                         ,
        rst_n                                       ,
        address          : {alu_result[31:2], 2'b00},
        write_data       : mem_write_data           ,
        byte_write_enable: byte_write_enable        ,
        read_data        : mem_raw_read             ,
    );

    // Split the reads into bytes, halfwords or words, depending on the op
    // This module is in the second pipeline stage (writeback)
    inst mem_reader: Reader (
        mem_data: mem_raw_read              ,
        be_mask : writeback.byte_enable_mask,
        f3      : writeback.f3              ,

        wb_data: mem_read_data ,
        valid  : mem_read_valid,
    );

}
