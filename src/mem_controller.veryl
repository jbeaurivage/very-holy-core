/// Memory instantaniating a Block RAM
/// Byte addressed, but only supports
/// word-aligned reads and writes.
/// Misaligned requests will be silently ignored
///
/// Timing
/// BRAM has a 1-cycle read and write latencies.
/// read_valid will be asserted when a read is valid.
module MemoryController #(
    param INIT_FILE: string = "",
    /// Number of words
    param RAM_DEPTH: u32 = 1024,
) (
    clk  : input clock,
    rst_n: input reset,
    /// Memory is word-addressed. Use byte_enable to write individual bytes
    address   : input logic<32>,
    write_data: input logic<32>,
    /// Byte enable mask, for writing individual bytes from a word
    byte_write_enable: input logic<4>,

    read_data: output logic<32>,
) {
    const ADDR_WIDTH: u32 = $clog2(RAM_DEPTH);
    const NUM_COL   : u8  = 4;
    const COL_WIDTH : u8  = 8;

    // Take the word-aligned part of the address
    /* verilator lint_off WIDTHTRUNC */
    let aligned_address: logic<30> = (address >> 2);
    /* verilator lint_on WIDTHTRUNC */

    // Inhibit misaligned requests
    let allow: bool = address[1:0] == 0;

    inst port       : BramPort #( ADDR_WIDTH, NUM_COL, COL_WIDTH );
    assign port.enable = allow;
    /* verilator lint_off WIDTHTRUNC */
    assign port.address = aligned_address;
    /* verilator lint_on WIDTHTRUNC */
    assign port.write_data        = write_data;
    assign port.byte_write_enable = byte_write_enable;
    assign read_data              = port.read_data;

    inst ram: SinglePortBlockRam #(
        INIT_FILE : INIT_FILE,
        NUM_COL              ,
        COL_WIDTH            ,
        RAM_DEPTH            ,
        ADDR_WIDTH           ,
    ) (
        clk    ,
        rst_n  ,
        port   ,
    );
}
